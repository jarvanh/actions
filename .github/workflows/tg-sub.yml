name: Sync Telegram Proxies to Gist

on:
  schedule:
    - cron: '10 * * * *'
  workflow_dispatch: # 允许手动点击运行

jobs:
  merge-and-push:
    runs-on: ubuntu-latest
    
    steps:
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: Install dependencies
      run: |
        pip install telethon PyGithub pyyaml

    - name: Create Python Script
      run: |
        cat > sync_proxies.py << 'EOF'
        import os
        import asyncio
        import yaml
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        from github import Github
        import time

        # 获取环境变量
        api_id = int(os.environ['TG_API_ID'])
        api_hash = os.environ['TG_API_HASH']
        session_str = os.environ['TG_SESSION']
        PAT = os.environ['PAT']
        TG_SUB_GIST_ID = os.environ['TG_SUB_GIST_ID']
        channel = os.environ['TARGET_CHANNEL']
        filename = os.environ['GIST_FILENAME']

        async def main():
            print(f'正在连接 Telegram...')
            client = TelegramClient(StringSession(session_str), api_id, api_hash)
            await client.start()

            print(f'正在扫描频道: {channel}')
            
            combined_proxies = []
            count = 0
            
            # 遍历最近的 50 条消息
            async for message in client.iter_messages(channel, limit=50):
                if count >= 10:
                    break
                
                # 检查是否为 yaml/yml 附件
                if message.file and message.file.name and message.file.name.lower().endswith(('.yaml', '.yml')):
                    try:
                        print(f'发现文件: {message.file.name}...')
                        file_data = await message.download_media(file=bytes)
                        content = yaml.safe_load(file_data)
                        
                        if content and 'proxies' in content and isinstance(content['proxies'], list):
                            # 将该文件的节点加入总列表
                            combined_proxies.extend(content['proxies'])
                            count += 1
                            print(f"  -> 成功提取 {len(content['proxies'])} 个节点")
                        else:
                            print(f'  -> 跳过: 格式不符或无 proxies 字段')
                    except Exception as e:
                        print(f'  -> 处理错误: {e}')

            await client.disconnect()

            if not combined_proxies:
                print('未找到任何有效节点，终止运行。')
                return

            print(f'\n扫描结束，共整合 {len(combined_proxies)} 个节点。')

            # 构建最终 YAML
            final_data = {'proxies': combined_proxies}
            final_yaml = yaml.dump(final_data, allow_unicode=True, sort_keys=False, default_flow_style=False)
            
            # 将 YAML 内容保存到临时文件
            temp_file = f"temp_{filename}"
            with open(temp_file, 'w', encoding='utf-8') as f:
                f.write(final_yaml)
            
            print(f'YAML 内容已保存到 {temp_file}，文件大小: {len(final_yaml)} 字节')
            
            # 读取文件内容以确认
            with open(temp_file, 'r', encoding='utf-8') as f:
                file_content = f.read()
                print(f"文件前100个字符: {file_content[:100]}...")

            # 上传到 Gist
            try:
                print('正在上传至 Gist...')
                g = Github(PAT)
                gist = g.get_gist(TG_SUB_GIST_ID)
                
                # 获取当前Gist文件列表
                existing_files = list(gist.files.keys())
                print(f'Gist 原始文件: {existing_files}')
                
                # 创建文件字典，确保我们更新所有文件
                files_dict = {}
                
                # 复制现有文件
                for file_name in existing_files:
                    if file_name != filename:  # 不复制我们要更新的文件
                        # 获取现有文件内容
                        try:
                            files_dict[file_name] = {
                                'content': gist.files[file_name].content
                            }
                            print(f"保留现有文件: {file_name}")
                        except Exception as e:
                            print(f"获取文件 {file_name} 内容失败: {e}")
                
                # 添加/更新我们要的文件
                files_dict[filename] = {'content': file_content}
                print(f"添加/更新文件: {filename}")
                
                # 更新Gist
                gist.edit(files=files_dict)
                print('✅ Gist 更新成功！')
                
                # 清理临时文件
                if os.path.exists(temp_file):
                    os.remove(temp_file)
                    
            except Exception as e:
                print(f'❌ Gist 更新失败: {e}')
                import traceback
                traceback.print_exc()
                
                # 如果失败，保存错误日志
                error_log = f'error_log_{int(time.time())}.txt'
                with open(error_log, 'w', encoding='utf-8') as f:
                    f.write(f"Error: {e}\n\n")
                    f.write(f"Traceback:\n")
                    traceback.print_exc(file=f)
                print(f'错误日志已保存到: {error_log}')
                
                exit(1)

        if __name__ == '__main__':
            asyncio.run(main())
        EOF

    - name: Execute Sync Script
      env:
        TG_API_ID: ${{ secrets.TG_API_ID }}
        TG_API_HASH: ${{ secrets.TG_API_HASH }}
        TG_SESSION: ${{ secrets.TG_SESSION }}
        PAT: ${{ secrets.PAT }}
        TG_SUB_GIST_ID: ${{ secrets.TG_SUB_GIST_ID }}
        TARGET_CHANNEL: 'SubscriptionShare'
        GIST_FILENAME: 'subscribe.yaml'
      run: |
        python sync_proxies.py
