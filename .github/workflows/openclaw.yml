name: openclaw

on:
  schedule:
    - cron: "*/5 * * * *"
  workflow_dispatch:
    inputs:
      maintenance_mode:
        description: '选择运行模式'
        required: true
        default: 'normal'
        type: choice
        options:
        - normal
        - generate_dashboard_link
        - list_devices
        - approve_device
      request_id:
        description: '输入 Request ID (仅在 approve_device 模式下需要)'
        required: false

jobs:
  build:
    concurrency: openclaw-singleton
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Install Rclone
        run: |
          curl -O https://downloads.rclone.org/rclone-current-linux-amd64.zip
          unzip rclone-*-amd64.zip
          cd rclone-*-linux-amd64
          sudo mv rclone /usr/bin
          sudo chmod +x /usr/bin/rclone

      - name: Configure Rclone
        env:
          RCLONE_CONFIG: ${{ secrets.RCLONE }}
        run: |
          mkdir -p ~/.config/rclone/
          cat << EOF > ~/.config/rclone/rclone.conf
          $RCLONE_CONFIG
          EOF

      - name: Mount Dropbox
        run: |
          sudo apt-get install fuse3
          sudo mkdir -p /dropbox
          
          # 挂载 Dropbox
          sudo nohup rclone mount dropbox: /dropbox \
            --allow-non-empty \
            --no-gzip-encoding \
            --umask 000 \
            --allow-other \
            --attr-timeout 10m \
            --vfs-cache-mode full \
            --vfs-cache-max-age 5m \
            --vfs-read-chunk-size-limit 10G \
            --buffer-size 100M \
            --vfs-cache-max-size 10G &
          
          echo "Waiting for mount..."
          sleep 10
          mkdir -p /dropbox/self-hosted/openclaw

      # 统一安装 Cloudflared (所有模式都需要安装，但不一定都运行)
      - name: Install Cloudflared
        run: |
          wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i cloudflared-linux-amd64.deb
          sudo mkdir -p ~/.cloudflared/
          sudo cp -r /dropbox/self-hosted/.cloudflared/* ~/.cloudflared/ 2>/dev/null || true

      - name: Start OpenClaw Container
        env:
          TOKEN: ${{ secrets.OPENCLAW_TOKEN }} 
        run: |
          [ -z "$TOKEN" ] && TOKEN="default-token"

          sudo docker run -d \
            --name openclaw \
            --network host \
            --restart unless-stopped \
            -e OPENCLAW_GATEWAY_TOKEN="$TOKEN" \
            -v /dropbox/self-hosted/openclaw:/config \
            alpine/openclaw
          
          echo "OpenClaw container started."
          sleep 10

      # --- 维护模式逻辑开始 ---

      - name: "[Mode] Generate Dashboard Link"
        if: ${{ github.event.inputs.maintenance_mode == 'generate_dashboard_link' }}
        run: |
          # 1. 先启动隧道，这样才能从公网访问
          echo "Starting Cloudflare Tunnel for remote access..."
          cloudflared tunnel route dns oc oc.'${{ secrets.VD }}'.eu.org
          nohup cloudflared tunnel run --url http://127.0.0.1:18789 oc > tunnel.log 2>&1 &
          sleep 5
          
          # 2. 查找入口文件
          echo "Detecting entrypoint..."
          ENTRY_CMD=$(sudo docker inspect --format='{{range .Config.Cmd}}{{.}} {{end}}' openclaw)
          JS_FILE=$(echo "$ENTRY_CMD" | grep -oE '/app/[a-zA-Z0-9_./-]+\.js' | head -n 1)
          
          # 兜底查找
          if [ -z "$JS_FILE" ]; then
             for path in /app/index.js /app/dist/index.js /app/main.js; do
                if sudo docker exec openclaw ls $path >/dev/null 2>&1; then JS_FILE=$path; break; fi
             done
          fi
          
          echo "Executing Dashboard command..."
          
          # 3. 获取链接
          # 注意：我们在后台运行它，并把日志输出出来，这样不会阻塞，但能看到 token
          sudo docker exec openclaw node $JS_FILE dashboard --no-open > dashboard_output.txt 2>&1 &
          
          # 等待一下让日志生成
          sleep 5
          
          echo "========================================================"
          echo "【操作指南】"
          echo "1. 下方会显示一个类似 http://127.0.0.1:18789/?token=*** 的链接"
          echo "2. GitHub 把 Token 隐藏了(显示为***)，那个 *** 其实就是您的 secrets.OPENCLAW_TOKEN"
          echo "3. 请在浏览器中拼接并访问以下地址："
          echo ""
          echo "   https://oc.${{ secrets.VD }}.eu.org/?token=${{ secrets.OPENCLAW_TOKEN }}"
          echo ""
          echo "4. 访问后，浏览器应提示 'Pairing request sent'。"
          echo "5. 看到提示后，手动停止此 Workflow，去运行 'list_devices' 模式。"
          echo "========================================================"
          
          echo "--- 原始日志 ---"
          cat dashboard_output.txt
          echo "----------------"
          
          # 保持运行，给你时间去访问
          sleep 600

      - name: "[Mode] List Devices"
        if: ${{ github.event.inputs.maintenance_mode == 'list_devices' }}
        run: |
          # 查找入口
          JS_FILE=""
          for path in /app/index.js /app/dist/index.js /app/main.js; do
            if sudo docker exec openclaw ls $path >/dev/null 2>&1; then JS_FILE=$path; break; fi
          done
          if [ -z "$JS_FILE" ]; then
             ENTRY_CMD=$(sudo docker inspect --format='{{range .Config.Cmd}}{{.}} {{end}}' openclaw)
             JS_FILE=$(echo "$ENTRY_CMD" | grep -oE '/app/[a-zA-Z0-9_./-]+\.js' | head -n 1)
          fi
          
          echo "Executing using: $JS_FILE"
          sudo docker exec openclaw node $JS_FILE devices list
          
          echo "========================================================"
          echo "请复制上面的 Request ID (requestId)。"
          echo "然后运行 'approve_device' 模式。"
          echo "========================================================"

      - name: "[Mode
